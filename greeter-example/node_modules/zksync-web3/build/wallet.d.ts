import { EIP712Signer } from './signer';
import { Provider } from './provider';
import { ethers, utils } from 'ethers';
import { BlockTag, TransactionResponse, TransactionRequest } from './types';
import { ProgressCallback } from '@ethersproject/json-wallets';
declare const Wallet_base: {
    new (...args: any[]): {
        _providerL2(): Provider;
        _signerL2(): ethers.Signer;
        getBalance(token?: string, blockTag?: BlockTag): Promise<ethers.BigNumber>;
        getAllBalances(): Promise<import("./types").BalancesMap>;
        _fillCustomData(data: import("./types").Eip712Meta): import("./types").Eip712Meta;
        withdraw(tx: {
            amount: ethers.BigNumberish;
            token: string;
            to?: string;
            feeToken?: string;
            nonce?: ethers.BigNumberish;
            gasLimit?: ethers.BigNumberish;
        }): Promise<TransactionResponse>;
        transfer(tx: {
            to: string;
            amount: ethers.BigNumberish;
            token?: string;
            feeToken?: string;
            nonce?: ethers.BigNumberish;
            gasLimit?: ethers.BigNumberish;
        }): Promise<TransactionResponse>;
        sendTransaction(tx: ethers.providers.TransactionRequest): Promise<ethers.providers.TransactionResponse>;
        getAddress(): Promise<string>;
    };
} & {
    new (...args: any[]): {
        _providerL2(): Provider;
        _providerL1(): ethers.providers.Provider;
        _signerL1(): ethers.Signer;
        getMainContract(): Promise<ethers.Contract>;
        getBalanceL1(token?: string, blockTag?: ethers.providers.BlockTag): Promise<ethers.BigNumber>;
        approveERC20(token: string, amount: ethers.BigNumberish, overrides?: ethers.CallOverrides): Promise<ethers.providers.TransactionResponse>;
        depositBaseCost(params?: {
            gasPrice?: ethers.BigNumberish;
            queueType?: import("./types").PriorityQueueType;
            opTree?: import("./types").PriorityOpTree;
        }): Promise<ethers.BigNumber>;
        addTokenBaseCost(params?: {
            gasPrice?: ethers.BigNumberish;
            queueType?: import("./types").PriorityQueueType;
            opTree?: import("./types").PriorityOpTree;
        }): Promise<ethers.BigNumber>;
        withdrawBaseCost(params?: {
            gasPrice?: ethers.BigNumberish;
            queueType?: import("./types").PriorityQueueType;
            opTree?: import("./types").PriorityOpTree;
        }): Promise<ethers.BigNumber>;
        executeBaseCost(params: {
            ergsLimit: ethers.BigNumberish;
            calldataLength: ethers.BigNumberish;
            gasPrice?: ethers.BigNumberish;
            queueType?: import("./types").PriorityQueueType;
            opTree?: import("./types").PriorityOpTree;
        }): Promise<ethers.BigNumber>;
        deployContractBaseCost(params?: {
            ergsLimit: ethers.BigNumberish;
            bytecodeLength: ethers.BigNumberish;
            calldataLength: ethers.BigNumberish;
            gasPrice?: ethers.BigNumberish;
            queueType?: import("./types").PriorityQueueType;
            opTree?: import("./types").PriorityOpTree;
        }): Promise<ethers.BigNumber>;
        deposit(transaction: {
            token: string;
            amount: ethers.BigNumberish;
            to?: string;
            queueType?: import("./types").PriorityQueueType;
            opTree?: import("./types").PriorityOpTree;
            operatorTip?: ethers.BigNumberish;
            approveERC20?: boolean;
            overrides?: ethers.CallOverrides;
            approveOverrides?: ethers.CallOverrides;
        }): Promise<import("./types").PriorityOpResponse>;
        addToken(transaction: {
            token: string;
            queueType?: import("./types").PriorityQueueType;
            opTree?: import("./types").PriorityOpTree;
            operatorTip?: ethers.BigNumberish;
            overrides?: ethers.CallOverrides;
        }): Promise<import("./types").PriorityOpResponse>;
        requestL1Withdraw(transaction: {
            token: string;
            amount: ethers.BigNumberish;
            to: string;
            queueType?: import("./types").PriorityQueueType;
            opTree?: import("./types").PriorityOpTree;
            operatorTip?: ethers.BigNumberish;
            overrides?: ethers.CallOverrides;
        }): Promise<import("./types").PriorityOpResponse>;
        requestL1Execute(transaction: {
            contractAddress: string;
            calldata: ethers.utils.BytesLike;
            ergsLimit: ethers.BigNumberish;
            queueType?: import("./types").PriorityQueueType;
            opTree?: import("./types").PriorityOpTree;
            operatorTip?: ethers.BigNumberish;
            overrides?: ethers.CallOverrides;
        }): Promise<import("./types").PriorityOpResponse>;
        requestL1DeployContract(transaction: {
            bytecode: ethers.utils.BytesLike;
            calldata: ethers.utils.BytesLike;
            ergsLimit: ethers.BigNumberish;
            queueType?: import("./types").PriorityQueueType;
            opTree?: import("./types").PriorityOpTree;
            operatorTip?: ethers.BigNumberish;
            overrides?: ethers.CallOverrides;
        }): Promise<import("./types").PriorityOpResponse>;
        sendTransaction(tx: ethers.providers.TransactionRequest): Promise<ethers.providers.TransactionResponse>;
        getAddress(): Promise<string>;
    };
} & typeof ethers.Wallet;
export declare class Wallet extends Wallet_base {
    readonly provider: Provider;
    providerL1?: ethers.providers.Provider;
    eip712: EIP712Signer;
    _providerL1(): ethers.providers.Provider;
    _providerL2(): Provider;
    _signerL1(): ethers.Wallet;
    _signerL2(): this;
    ethWallet(): ethers.Wallet;
    getNonce(blockTag?: BlockTag): Promise<number>;
    connect(provider: Provider): Wallet;
    connectToL1(provider: ethers.providers.Provider): Wallet;
    static fromMnemonic(mnemonic: string, path?: string, wordlist?: ethers.Wordlist): Wallet;
    static fromEncryptedJson(json: string, password?: string | ethers.Bytes, callback?: ProgressCallback): Promise<Wallet>;
    static fromEncryptedJsonSync(json: string, password?: string | ethers.Bytes): Wallet;
    static createRandom(options?: any): Wallet;
    constructor(privateKey: ethers.BytesLike | utils.SigningKey, providerL2?: Provider, providerL1?: ethers.providers.Provider);
    populateTransaction(transaction: TransactionRequest): Promise<TransactionRequest>;
    signTransaction(transaction: TransactionRequest): Promise<string>;
    sendTransaction(transaction: ethers.providers.TransactionRequest): Promise<TransactionResponse>;
}
export {};
