import { BigNumber, BigNumberish, ethers, BytesLike } from 'ethers';
import { Provider } from './provider';
import { Address, PriorityOpResponse, BlockTag, Eip712Meta, PriorityQueueType, PriorityOpTree, TransactionResponse, BalancesMap } from './types';
declare type Constructor<T = {}> = new (...args: any[]) => T;
interface TxSender {
    sendTransaction(tx: ethers.providers.TransactionRequest): Promise<ethers.providers.TransactionResponse>;
    getAddress(): Promise<Address>;
}
export declare function AdapterL1<TBase extends Constructor<TxSender>>(Base: TBase): {
    new (...args: any[]): {
        _providerL2(): Provider;
        _providerL1(): ethers.providers.Provider;
        _signerL1(): ethers.Signer;
        getMainContract(): Promise<ethers.Contract>;
        getBalanceL1(token?: Address, blockTag?: ethers.providers.BlockTag): Promise<BigNumber>;
        approveERC20(token: Address, amount: BigNumberish, overrides?: ethers.CallOverrides): Promise<ethers.providers.TransactionResponse>;
        depositBaseCost(params?: {
            gasPrice?: BigNumberish;
            queueType?: PriorityQueueType;
            opTree?: PriorityOpTree;
        }): Promise<BigNumber>;
        addTokenBaseCost(params?: {
            gasPrice?: BigNumberish;
            queueType?: PriorityQueueType;
            opTree?: PriorityOpTree;
        }): Promise<BigNumber>;
        withdrawBaseCost(params?: {
            gasPrice?: BigNumberish;
            queueType?: PriorityQueueType;
            opTree?: PriorityOpTree;
        }): Promise<BigNumber>;
        executeBaseCost(params: {
            ergsLimit: BigNumberish;
            calldataLength: BigNumberish;
            gasPrice?: BigNumberish;
            queueType?: PriorityQueueType;
            opTree?: PriorityOpTree;
        }): Promise<BigNumber>;
        deployContractBaseCost(params?: {
            ergsLimit: BigNumberish;
            bytecodeLength: BigNumberish;
            calldataLength: BigNumberish;
            gasPrice?: BigNumberish;
            queueType?: PriorityQueueType;
            opTree?: PriorityOpTree;
        }): Promise<BigNumber>;
        deposit(transaction: {
            token: Address;
            amount: BigNumberish;
            to?: Address;
            queueType?: PriorityQueueType;
            opTree?: PriorityOpTree;
            operatorTip?: BigNumberish;
            approveERC20?: boolean;
            overrides?: ethers.CallOverrides;
            approveOverrides?: ethers.CallOverrides;
        }): Promise<PriorityOpResponse>;
        addToken(transaction: {
            token: Address;
            queueType?: PriorityQueueType;
            opTree?: PriorityOpTree;
            operatorTip?: BigNumberish;
            overrides?: ethers.CallOverrides;
        }): Promise<PriorityOpResponse>;
        requestL1Withdraw(transaction: {
            token: Address;
            amount: BigNumberish;
            to: Address;
            queueType?: PriorityQueueType;
            opTree?: PriorityOpTree;
            operatorTip?: BigNumberish;
            overrides?: ethers.CallOverrides;
        }): Promise<PriorityOpResponse>;
        requestL1Execute(transaction: {
            contractAddress: Address;
            calldata: BytesLike;
            ergsLimit: BigNumberish;
            queueType?: PriorityQueueType;
            opTree?: PriorityOpTree;
            operatorTip?: BigNumberish;
            overrides?: ethers.CallOverrides;
        }): Promise<PriorityOpResponse>;
        requestL1DeployContract(transaction: {
            bytecode: BytesLike;
            calldata: BytesLike;
            ergsLimit: BigNumberish;
            queueType?: PriorityQueueType;
            opTree?: PriorityOpTree;
            operatorTip?: BigNumberish;
            overrides?: ethers.CallOverrides;
        }): Promise<PriorityOpResponse>;
        sendTransaction(tx: ethers.providers.TransactionRequest): Promise<ethers.providers.TransactionResponse>;
        getAddress(): Promise<string>;
    };
} & TBase;
export declare function AdapterL2<TBase extends Constructor<TxSender>>(Base: TBase): {
    new (...args: any[]): {
        _providerL2(): Provider;
        _signerL2(): ethers.Signer;
        getBalance(token?: Address, blockTag?: BlockTag): Promise<BigNumber>;
        getAllBalances(): Promise<BalancesMap>;
        _fillCustomData(data: Eip712Meta): Eip712Meta;
        withdraw(tx: {
            amount: BigNumberish;
            token: Address;
            to?: Address;
            feeToken?: Address;
            nonce?: BigNumberish;
            gasLimit?: BigNumberish;
        }): Promise<TransactionResponse>;
        transfer(tx: {
            to: Address;
            amount: BigNumberish;
            token?: Address;
            feeToken?: Address;
            nonce?: BigNumberish;
            gasLimit?: BigNumberish;
        }): Promise<TransactionResponse>;
        sendTransaction(tx: ethers.providers.TransactionRequest): Promise<ethers.providers.TransactionResponse>;
        getAddress(): Promise<string>;
    };
} & TBase;
export {};
