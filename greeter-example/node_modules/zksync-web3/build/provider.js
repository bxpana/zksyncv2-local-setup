"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Web3Provider = exports.Provider = void 0;
const ethers_1 = require("ethers");
var Formatter = ethers_1.providers.Formatter;
const types_1 = require("./types");
const utils_1 = require("./utils");
const signer_1 = require("./signer");
class Provider extends ethers_1.ethers.providers.JsonRpcProvider {
    constructor(url, network) {
        super(url, network);
        this.pollingInterval = 500;
        const blockTag = this.formatter.blockTag.bind(this.formatter);
        this.formatter.blockTag = (tag) => {
            if (tag == 'committed' || tag == 'finalized') {
                return tag;
            }
            return blockTag(tag);
        };
        this.formatter.transaction = utils_1.parseTransaction;
    }
    async getBalance(address, blockTag, tokenAddress) {
        const tag = this.formatter.blockTag(blockTag);
        tokenAddress !== null && tokenAddress !== void 0 ? tokenAddress : (tokenAddress = utils_1.ETH_ADDRESS);
        return ethers_1.BigNumber.from(await this.send('eth_getBalance', [address, tag, tokenAddress]));
    }
    // This function is used when formatting requests for
    // eth_call and eth_estimateGas. We override it here
    // because we have extra stuff to serialize (customData).
    // This function is for internal use only.
    static hexlifyTransaction(transaction, allowExtra) {
        var _a, _b, _c;
        const result = ethers_1.ethers.providers.JsonRpcProvider.hexlifyTransaction(transaction, {
            ...allowExtra,
            customData: true,
            from: true
        });
        if (transaction.customData == null) {
            return result;
        }
        result.eip712Meta = {
            feeToken: ethers_1.utils.hexlify((_a = transaction.customData.feeToken) !== null && _a !== void 0 ? _a : utils_1.ETH_ADDRESS),
            ergsPerStorage: ethers_1.utils.hexValue((_b = transaction.customData.ergsPerStorage) !== null && _b !== void 0 ? _b : 0),
            ergsPerPubdata: ethers_1.utils.hexValue((_c = transaction.customData.ergsPerPubdata) !== null && _c !== void 0 ? _c : 0)
        };
        if (transaction.customData.withdrawToken) {
            // @ts-ignore
            result.eip712Meta.withdrawToken = ethers_1.utils.hexlify(transaction.customData.withdrawToken);
        }
        if (transaction.customData.factoryDeps) {
            // @ts-ignore
            result.eip712Meta.factoryDeps = transaction.customData.factoryDeps.map((dep) => 
            // TODO: we arraify instead of hexlifying because server expects Vec<u8>.
            // We should change deserealization there.
            Array.from(ethers_1.utils.arrayify(dep)));
        }
        return result;
    }
    async estimateGas(transaction) {
        await this.getNetwork();
        const params = await ethers_1.utils.resolveProperties({
            transaction: this._getTransactionRequest(transaction)
        });
        if (transaction.customData != null) {
            // @ts-ignore
            params.transaction.customData = transaction.customData;
        }
        const result = await this.perform('estimateGas', params);
        try {
            return ethers_1.BigNumber.from(result);
        }
        catch (error) {
            throw new Error(`bad result from backend (estimateGas): ${result}`);
        }
    }
    async getGasPrice(token) {
        const params = token ? [token] : [];
        const price = await this.send('eth_gasPrice', params);
        return ethers_1.BigNumber.from(price);
    }
    async getMainContractAddress() {
        if (!this.contractAddress) {
            this.contractAddress = await this.send('zks_getMainContract', []);
        }
        return this.contractAddress;
    }
    async getAccountTransactions(address, before = 0, limit = 255) {
        const history = await this.send('zks_getAccountTransactions', [address, before, limit]);
        return Formatter.arrayOf(this.formatter.transactionResponse.bind(this.formatter))(history);
    }
    async getConfirmedTokens(start = 0, limit = 255) {
        return await this.send('zks_getConfirmedTokens', [start, limit]);
    }
    async isTokenLiquid(token) {
        return await this.send('zks_isTokenLiquid', [token]);
    }
    async getTokenPrice(token) {
        return await this.send('zks_getTokenPrice', [token]);
    }
    async getAllAccountBalances(address) {
        let balances = await this.send('zks_getAllAccountBalances', [address]);
        for (let token in balances) {
            balances[token] = ethers_1.BigNumber.from(balances[token]);
        }
        return balances;
    }
    static getDefaultProvider() {
        // TODO: different urls for different networks
        return new Provider(process.env.ZKSYNC_WEB3_API_URL || 'http://localhost:3050');
    }
    async newFilter(filter) {
        filter = await filter;
        const id = await this.send('eth_newFilter', [this._prepareFilter(filter)]);
        return ethers_1.BigNumber.from(id);
    }
    async newBlockFilter() {
        const id = await this.send('eth_newBlockFilter', []);
        return ethers_1.BigNumber.from(id);
    }
    async newPendingTransactionsFilter() {
        const id = await this.send('eth_newPendingTransactionFilter', []);
        return ethers_1.BigNumber.from(id);
    }
    async getFilterChanges(idx) {
        const logs = await this.send('eth_getFilterChanges', [idx.toHexString()]);
        return typeof logs[0] === 'string' ? logs : this._parseLogs(logs);
    }
    async getLogs(filter = {}) {
        filter = await filter;
        const logs = await this.send('eth_getLogs', [this._prepareFilter(filter)]);
        return this._parseLogs(logs);
    }
    _parseLogs(logs) {
        return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);
    }
    _prepareFilter(filter) {
        return {
            ...filter,
            fromBlock: filter.fromBlock == null ? null : this.formatter.blockTag(filter.fromBlock),
            toBlock: filter.fromBlock == null ? null : this.formatter.blockTag(filter.toBlock)
        };
    }
    _wrapTransaction(tx, hash) {
        const response = super._wrapTransaction(tx, hash);
        response.waitFinalize = async () => {
            const receipt = await response.wait();
            while (true) {
                const block = await this.getBlock('finalized');
                if (receipt.blockNumber <= block.number) {
                    return receipt;
                }
                else {
                    await (0, utils_1.sleep)(this.pollingInterval);
                }
            }
        };
        return response;
    }
    // This is inefficient. Status should probably be indicated in the transaction receipt.
    async getTransactionStatus(txHash) {
        const tx = await this.getTransaction(txHash);
        if (tx == null) {
            return types_1.TransactionStatus.NotFound;
        }
        if (tx.blockNumber == null) {
            return types_1.TransactionStatus.Processing;
        }
        const verifiedBlock = await this.getBlock('finalized');
        if (tx.blockNumber <= verifiedBlock.number) {
            return types_1.TransactionStatus.Finalized;
        }
        return types_1.TransactionStatus.Committed;
    }
    async getTransaction(hash) {
        hash = await hash;
        const tx = await super.getTransaction(hash);
        return tx ? this._wrapTransaction(tx, hash) : null;
    }
    async getL1Withdrawal(withdrawalHash) {
        return await this.send('zks_getL1WithdrawalTx', [withdrawalHash]);
    }
    async sendTransaction(transaction) {
        return (await super.sendTransaction(transaction));
    }
    async getL2TransactionFromPriorityOp(l1TxResponse) {
        const receipt = await l1TxResponse.wait();
        const l2Hash = (0, utils_1.getL2HashFromPriorityOp)(receipt, await this.getMainContractAddress());
        let status = null;
        do {
            status = await this.getTransactionStatus(l2Hash);
            await (0, utils_1.sleep)(this.pollingInterval);
        } while (status == types_1.TransactionStatus.NotFound);
        return await this.getTransaction(l2Hash);
    }
    async getPriorityOpResponse(l1TxResponse) {
        const l2Response = { ...l1TxResponse };
        l2Response.waitL1Commit = l2Response.wait;
        l2Response.wait = async () => {
            const l2Tx = await this.getL2TransactionFromPriorityOp(l1TxResponse);
            return await l2Tx.wait();
        };
        l2Response.waitFinalize = async () => {
            const l2Tx = await this.getL2TransactionFromPriorityOp(l1TxResponse);
            return await l2Tx.waitFinalize();
        };
        return l2Response;
    }
}
exports.Provider = Provider;
class Web3Provider extends Provider {
    constructor(provider, network) {
        if (provider == null) {
            throw new Error('missing provider');
        }
        if (!provider.request) {
            throw new Error('provider must implement eip-1193');
        }
        let path = provider.host || provider.path || (provider.isMetaMask ? 'metamask' : 'eip-1193:');
        super(path, network);
        this.provider = provider;
    }
    async send(method, params) {
        params !== null && params !== void 0 ? params : (params = []);
        // Metamask complains about eth_sign (and on some versions hangs)
        if (method == 'eth_sign' && (this.provider.isMetaMask || this.provider.isStatus)) {
            // https://github.com/ethereum/go-ethereum/wiki/Management-APIs#personal_sign
            method = 'personal_sign';
            params = [params[1], params[0]];
        }
        return await this.provider.request({ method, params });
    }
    getSigner(addressOrIndex) {
        return signer_1.Signer.from(super.getSigner(addressOrIndex));
    }
    async estimateGas(transaction) {
        const gas = await super.estimateGas(transaction);
        const metamaskMinimum = ethers_1.BigNumber.from(21000);
        const isEIP712 = transaction.customData != null || transaction.type == 0x70;
        return gas.gt(metamaskMinimum) || isEIP712 ? gas : metamaskMinimum;
    }
}
exports.Web3Provider = Web3Provider;
