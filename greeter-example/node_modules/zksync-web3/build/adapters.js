"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AdapterL2 = exports.AdapterL1 = void 0;
const ethers_1 = require("ethers");
const utils_1 = require("./utils");
const types_1 = require("./types");
function AdapterL1(Base) {
    return class Adapter extends Base {
        _providerL2() {
            throw new Error('Must be implemented by the derived class!');
        }
        _providerL1() {
            throw new Error('Must be implemented by the derived class!');
        }
        _signerL1() {
            throw new Error('Must be implemented by the derived class!');
        }
        async getMainContract() {
            const address = await this._providerL2().getMainContractAddress();
            return new ethers_1.ethers.Contract(address, utils_1.ZKSYNC_MAIN_ABI, this._signerL1());
        }
        async getBalanceL1(token, blockTag) {
            token !== null && token !== void 0 ? token : (token = utils_1.ETH_ADDRESS);
            if ((0, utils_1.isETH)(token)) {
                return await this._providerL1().getBalance(await this.getAddress(), blockTag);
            }
            else {
                const erc20contract = new ethers_1.ethers.Contract(token, utils_1.IERC20, this._providerL1());
                return await erc20contract.balanceOf(await this.getAddress());
            }
        }
        async approveERC20(token, amount, overrides) {
            if ((0, utils_1.isETH)(token)) {
                throw new Error("ETH token can't be approved. The address of the token does not exist on L1.");
            }
            const erc20contract = new ethers_1.ethers.Contract(token, utils_1.IERC20, this._signerL1());
            const mainContract = await this._providerL2().getMainContractAddress();
            let gasLimit;
            if (overrides === null || overrides === void 0 ? void 0 : overrides.gasLimit) {
                gasLimit = await overrides.gasLimit;
            }
            else {
                // For some reason, gas estimation for approves may be imprecise.
                // At least in the localhost scenario.
                gasLimit = await erc20contract.estimateGas.approve(mainContract, amount);
                gasLimit = gasLimit.gt(utils_1.RECOMMENDED_GAS_LIMIT.ERC20_APPROVE)
                    ? gasLimit
                    : utils_1.RECOMMENDED_GAS_LIMIT.ERC20_APPROVE;
            }
            return await erc20contract.approve(mainContract, amount, { gasLimit, ...overrides });
        }
        async depositBaseCost(params) {
            var _a;
            const zksyncContract = await this.getMainContract();
            const parameters = { ...(0, utils_1.layer1TxDefaults)(), ...params };
            (_a = parameters.gasPrice) !== null && _a !== void 0 ? _a : (parameters.gasPrice = await this._providerL1().getGasPrice());
            return ethers_1.BigNumber.from(await zksyncContract.depositBaseCost(parameters.gasPrice, parameters.queueType, parameters.opTree));
        }
        async addTokenBaseCost(params) {
            var _a;
            const zksyncContract = await this.getMainContract();
            const parameters = { ...(0, utils_1.layer1TxDefaults)(), ...params };
            (_a = parameters.gasPrice) !== null && _a !== void 0 ? _a : (parameters.gasPrice = await this._providerL1().getGasPrice());
            return ethers_1.BigNumber.from(await zksyncContract.addTokenBaseCost(parameters.gasPrice, parameters.queueType, parameters.opTree));
        }
        async withdrawBaseCost(params) {
            var _a;
            const zksyncContract = await this.getMainContract();
            const parameters = { ...(0, utils_1.layer1TxDefaults)(), ...params };
            (_a = parameters.gasPrice) !== null && _a !== void 0 ? _a : (parameters.gasPrice = await this._providerL1().getGasPrice());
            return ethers_1.BigNumber.from(await zksyncContract.withdrawBaseCost(parameters.gasPrice, parameters.queueType, parameters.opTree));
        }
        async executeBaseCost(params) {
            var _a;
            const zksyncContract = await this.getMainContract();
            const parameters = { ...(0, utils_1.layer1TxDefaults)(), ...params };
            (_a = parameters.gasPrice) !== null && _a !== void 0 ? _a : (parameters.gasPrice = await this._providerL1().getGasPrice());
            return ethers_1.BigNumber.from(await zksyncContract.executeBaseCost(parameters.gasPrice, parameters.ergsLimit, parameters.calldataLength, parameters.queueType, parameters.opTree));
        }
        async deployContractBaseCost(params) {
            var _a;
            const zksyncContract = await this.getMainContract();
            const parameters = { ...(0, utils_1.layer1TxDefaults)(), ...params };
            (_a = parameters.gasPrice) !== null && _a !== void 0 ? _a : (parameters.gasPrice = await this._providerL1().getGasPrice());
            return ethers_1.BigNumber.from(await zksyncContract.deployContractBaseCost(parameters.gasPrice, parameters.ergsLimit, parameters.bytecodeLength, parameters.calldataLength, parameters.queueType, parameters.opTree));
        }
        async deposit(transaction) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            const zksyncContract = await this.getMainContract();
            const { ...tx } = transaction;
            (_a = tx.opTree) !== null && _a !== void 0 ? _a : (tx.opTree = types_1.PriorityOpTree.Full);
            (_b = tx.queueType) !== null && _b !== void 0 ? _b : (tx.queueType = types_1.PriorityQueueType.Deque);
            (_c = tx.to) !== null && _c !== void 0 ? _c : (tx.to = await this.getAddress());
            (_d = tx.operatorTip) !== null && _d !== void 0 ? _d : (tx.operatorTip = ethers_1.BigNumber.from(0));
            (_e = tx.overrides) !== null && _e !== void 0 ? _e : (tx.overrides = {});
            const { to, token, amount, queueType, opTree, operatorTip, overrides } = tx;
            (_f = overrides.gasPrice) !== null && _f !== void 0 ? _f : (overrides.gasPrice = await this._providerL1().getGasPrice());
            const baseCost = ethers_1.BigNumber.from(await zksyncContract.depositBaseCost(overrides.gasPrice, queueType, opTree));
            if ((0, utils_1.isETH)(token)) {
                (_g = overrides.value) !== null && _g !== void 0 ? _g : (overrides.value = baseCost.add(operatorTip).add(amount));
                await (0, utils_1.checkBaseCost)(baseCost, overrides.value);
                return this._providerL2().getPriorityOpResponse(await zksyncContract.depositETH(amount, to, queueType, opTree, {
                    gasLimit: ethers_1.BigNumber.from(utils_1.RECOMMENDED_GAS_LIMIT.ETH_DEPOSIT),
                    ...overrides
                }));
            }
            else {
                (_h = overrides.value) !== null && _h !== void 0 ? _h : (overrides.value = baseCost.add(operatorTip));
                await (0, utils_1.checkBaseCost)(baseCost, overrides.value);
                let l2ContractCode = await this._providerL2().getCode(token);
                if (l2ContractCode === '0x') {
                    throw new Error('Depositing token is not added to L2. Consider adding it with `AddToken` operation firstly.');
                }
                let nonce = undefined;
                if (transaction.approveERC20) {
                    const approveTx = await this.approveERC20(token, amount, transaction.approveOverrides);
                    nonce = approveTx.nonce + 1;
                }
                (_j = overrides.nonce) !== null && _j !== void 0 ? _j : (overrides.nonce = nonce);
                const args = [token, amount, to, queueType, opTree];
                if (overrides.gasLimit == null) {
                    const gasEstimate = await zksyncContract.estimateGas
                        .depositERC20(...args, overrides)
                        .catch(() => ethers_1.BigNumber.from(0));
                    const recommendedGasLimit = (_k = utils_1.RECOMMENDED_GAS_LIMIT.ERC20_DEPOSIT[token]) !== null && _k !== void 0 ? _k : utils_1.RECOMMENDED_GAS_LIMIT.ERC20_DEFAULT_DEPOSIT;
                    overrides.gasLimit = gasEstimate.gte(recommendedGasLimit) ? gasEstimate : recommendedGasLimit;
                }
                return await this._providerL2().getPriorityOpResponse(await zksyncContract.depositERC20(...args, overrides));
            }
        }
        async addToken(transaction) {
            var _a, _b, _c, _d, _e, _f;
            const zksyncContract = await this.getMainContract();
            const { ...tx } = transaction;
            (_a = tx.opTree) !== null && _a !== void 0 ? _a : (tx.opTree = types_1.PriorityOpTree.Full);
            (_b = tx.queueType) !== null && _b !== void 0 ? _b : (tx.queueType = types_1.PriorityQueueType.Deque);
            (_c = tx.operatorTip) !== null && _c !== void 0 ? _c : (tx.operatorTip = ethers_1.BigNumber.from(0));
            (_d = tx.overrides) !== null && _d !== void 0 ? _d : (tx.overrides = {});
            const { token, queueType, opTree, operatorTip, overrides } = tx;
            (_e = overrides.gasPrice) !== null && _e !== void 0 ? _e : (overrides.gasPrice = await this._providerL1().getGasPrice());
            const baseCost = ethers_1.BigNumber.from(await zksyncContract.addTokenBaseCost(overrides.gasPrice, queueType, opTree));
            (_f = overrides.value) !== null && _f !== void 0 ? _f : (overrides.value = baseCost.add(operatorTip));
            await (0, utils_1.checkBaseCost)(baseCost, overrides.value);
            return this._providerL2().getPriorityOpResponse(await zksyncContract.addToken(token, queueType, opTree, {
                gasLimit: ethers_1.BigNumber.from(utils_1.RECOMMENDED_GAS_LIMIT.ADD_TOKEN),
                ...overrides
            }));
        }
        async requestL1Withdraw(transaction) {
            var _a, _b, _c, _d, _e, _f;
            const zksyncContract = await this.getMainContract();
            const { ...tx } = transaction;
            (_a = tx.opTree) !== null && _a !== void 0 ? _a : (tx.opTree = types_1.PriorityOpTree.Full);
            (_b = tx.queueType) !== null && _b !== void 0 ? _b : (tx.queueType = types_1.PriorityQueueType.Deque);
            (_c = tx.operatorTip) !== null && _c !== void 0 ? _c : (tx.operatorTip = ethers_1.BigNumber.from(0));
            (_d = tx.overrides) !== null && _d !== void 0 ? _d : (tx.overrides = {});
            const { token, queueType, opTree, operatorTip, overrides, to, amount } = tx;
            (_e = overrides.gasPrice) !== null && _e !== void 0 ? _e : (overrides.gasPrice = await this._providerL1().getGasPrice());
            const baseCost = ethers_1.BigNumber.from(await zksyncContract.withdrawBaseCost(overrides.gasPrice, queueType, opTree));
            (_f = overrides.value) !== null && _f !== void 0 ? _f : (overrides.value = baseCost.add(operatorTip));
            await (0, utils_1.checkBaseCost)(baseCost, overrides.value);
            return this._providerL2().getPriorityOpResponse(await zksyncContract.requestWithdraw(token, amount, to, queueType, opTree, {
                gasLimit: ethers_1.BigNumber.from(utils_1.RECOMMENDED_GAS_LIMIT.WITHDRAW),
                ...overrides
            }));
        }
        async requestL1Execute(transaction) {
            var _a, _b, _c, _d, _e, _f;
            const zksyncContract = await this.getMainContract();
            const { ...tx } = transaction;
            (_a = tx.opTree) !== null && _a !== void 0 ? _a : (tx.opTree = types_1.PriorityOpTree.Full);
            (_b = tx.queueType) !== null && _b !== void 0 ? _b : (tx.queueType = types_1.PriorityQueueType.Deque);
            (_c = tx.operatorTip) !== null && _c !== void 0 ? _c : (tx.operatorTip = ethers_1.BigNumber.from(0));
            (_d = tx.overrides) !== null && _d !== void 0 ? _d : (tx.overrides = {});
            const { contractAddress, calldata, ergsLimit, queueType, opTree, operatorTip, overrides } = tx;
            (_e = overrides.gasPrice) !== null && _e !== void 0 ? _e : (overrides.gasPrice = await this._providerL1().getGasPrice());
            const baseCost = ethers_1.BigNumber.from(await zksyncContract.executeBaseCost(overrides.gasPrice, ergsLimit, ethers_1.ethers.utils.hexDataLength(calldata), queueType, opTree));
            (_f = overrides.value) !== null && _f !== void 0 ? _f : (overrides.value = baseCost.add(operatorTip));
            await (0, utils_1.checkBaseCost)(baseCost, overrides.value);
            return this._providerL2().getPriorityOpResponse(await zksyncContract.requestExecute(contractAddress, calldata, ergsLimit, queueType, opTree, {
                gasLimit: ethers_1.BigNumber.from(utils_1.RECOMMENDED_GAS_LIMIT.EXECUTE),
                ...overrides
            }));
        }
        async requestL1DeployContract(transaction) {
            var _a, _b, _c, _d, _e, _f;
            const zksyncContract = await this.getMainContract();
            const { ...tx } = transaction;
            (_a = tx.opTree) !== null && _a !== void 0 ? _a : (tx.opTree = types_1.PriorityOpTree.Full);
            (_b = tx.queueType) !== null && _b !== void 0 ? _b : (tx.queueType = types_1.PriorityQueueType.Deque);
            (_c = tx.operatorTip) !== null && _c !== void 0 ? _c : (tx.operatorTip = ethers_1.BigNumber.from(0));
            (_d = tx.overrides) !== null && _d !== void 0 ? _d : (tx.overrides = {});
            const { bytecode, calldata, ergsLimit, queueType, opTree, operatorTip, overrides } = tx;
            (_e = overrides.gasPrice) !== null && _e !== void 0 ? _e : (overrides.gasPrice = await this._providerL1().getGasPrice());
            const baseCost = ethers_1.BigNumber.from(await zksyncContract.deployContractBaseCost(overrides.gasPrice, ergsLimit, ethers_1.ethers.utils.hexDataLength(bytecode), ethers_1.ethers.utils.hexDataLength(calldata), queueType, opTree));
            (_f = overrides.value) !== null && _f !== void 0 ? _f : (overrides.value = baseCost.add(operatorTip));
            await (0, utils_1.checkBaseCost)(baseCost, overrides.value);
            return this._providerL2().getPriorityOpResponse(await zksyncContract.requestDeployContract(bytecode, calldata, ergsLimit, queueType, opTree, {
                gasLimit: ethers_1.BigNumber.from(utils_1.RECOMMENDED_GAS_LIMIT.DEPLOY_CONTRACT),
                ...overrides
            }));
        }
    };
}
exports.AdapterL1 = AdapterL1;
function AdapterL2(Base) {
    return class Adapter extends Base {
        _providerL2() {
            throw new Error('Must be implemented by the derived class!');
        }
        _signerL2() {
            throw new Error('Must be implemented by the derived class!');
        }
        async getBalance(token, blockTag = 'committed') {
            return await this._providerL2().getBalance(await this.getAddress(), blockTag, token);
        }
        async getAllBalances() {
            return await this._providerL2().getAllAccountBalances(await this.getAddress());
        }
        _fillCustomData(data) {
            var _a, _b, _c, _d, _e;
            const customData = { ...data };
            (_a = customData.feeToken) !== null && _a !== void 0 ? _a : (customData.feeToken = utils_1.ETH_ADDRESS);
            (_b = customData.ergsPerStorage) !== null && _b !== void 0 ? _b : (customData.ergsPerStorage = 0);
            (_c = customData.ergsPerPubdata) !== null && _c !== void 0 ? _c : (customData.ergsPerPubdata = 0);
            (_d = customData.withdrawToken) !== null && _d !== void 0 ? _d : (customData.withdrawToken = ethers_1.ethers.constants.AddressZero);
            (_e = customData.factoryDeps) !== null && _e !== void 0 ? _e : (customData.factoryDeps = []);
            return customData;
        }
        async withdraw(tx) {
            var _a;
            const txResponse = await this.sendTransaction({
                value: tx.amount,
                to: (_a = tx.to) !== null && _a !== void 0 ? _a : (await this.getAddress()),
                nonce: tx.nonce,
                gasLimit: tx.gasLimit,
                customData: {
                    feeToken: tx.feeToken,
                    withdrawToken: tx.token
                }
            });
            return this._providerL2()._wrapTransaction(txResponse);
        }
        async transfer(tx) {
            var _a;
            (_a = tx.token) !== null && _a !== void 0 ? _a : (tx.token = utils_1.ETH_ADDRESS);
            const token = new ethers_1.ethers.Contract(tx.token, utils_1.IERC20, this._signerL2());
            const overrides = {
                nonce: tx.nonce,
                gasLimit: tx.gasLimit,
                customData: {
                    feeToken: tx.feeToken
                }
            };
            if (tx.feeToken == null) {
                delete overrides.customData;
            }
            return await token.transfer(tx.to, tx.amount, overrides);
        }
    };
}
exports.AdapterL2 = AdapterL2;
