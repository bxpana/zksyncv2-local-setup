"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkNonZeroValue = exports.isTypedDataSignatureCorrect = exports.isMessageSignatureCorrect = exports.getL2HashFromPriorityOp = exports.getL2HashFromPriorityOpId = exports.parseTransaction = exports.serialize = exports.checkBaseCost = exports.layer1TxDefaults = exports.sleep = exports.isETH = exports.RECOMMENDED_GAS_LIMIT = exports.PRIORITY_OP_ID_BYTES = exports.IERC20 = exports.ZKSYNC_MAIN_ABI = exports.ETH_ADDRESS = void 0;
const ethers_1 = require("ethers");
const types_1 = require("./types");
const signer_1 = require("./signer");
exports.ETH_ADDRESS = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE';
exports.ZKSYNC_MAIN_ABI = new ethers_1.utils.Interface(require('../abi/ZkSync.json').abi);
exports.IERC20 = new ethers_1.utils.Interface(require('../abi/IERC20.json').abi);
exports.PRIORITY_OP_ID_BYTES = 8;
exports.RECOMMENDED_GAS_LIMIT = {
    ETH_DEPOSIT: 120000,
    ERC20_DEPOSIT: require('../misc/DepositERC20GasLimits.json'),
    ERC20_DEFAULT_DEPOSIT: 300000,
    WITHDRAW: 120000,
    EXECUTE: 120000,
    DEPLOY_CONTRACT: 720000,
    // TODO: Estimate these values.
    ADD_TOKEN: 300000,
    TRANSFER: 300000,
    ERC20_APPROVE: 50000
};
function isETH(token) {
    if (token == ethers_1.constants.AddressZero) {
        console.warn(`You are using the Zero Address as a token. If you meant ETH, please use ${exports.ETH_ADDRESS} instead.`);
    }
    return token.toLowerCase() == exports.ETH_ADDRESS.toLowerCase();
}
exports.isETH = isETH;
function sleep(millis) {
    return new Promise((resolve) => setTimeout(resolve, millis));
}
exports.sleep = sleep;
function layer1TxDefaults() {
    return {
        queueType: types_1.PriorityQueueType.Deque,
        opTree: types_1.PriorityOpTree.Full
    };
}
exports.layer1TxDefaults = layer1TxDefaults;
async function checkBaseCost(baseCost, value) {
    if (baseCost.gt(await value)) {
        throw new Error(`The base cost of performing the priority operation is higher than the provided value parameter ` +
            `for the transaction: baseCost: ${baseCost}, provided value: ${value}`);
    }
}
exports.checkBaseCost = checkBaseCost;
function serialize(transaction, signature) {
    var _a;
    if (transaction.customData == null && transaction.type != 0x70) {
        return ethers_1.utils.serializeTransaction(transaction, signature);
    }
    if (!transaction.chainId) {
        throw Error("Transaction chainId isn't set");
    }
    function formatNumber(value, name) {
        const result = ethers_1.utils.stripZeros(ethers_1.BigNumber.from(value).toHexString());
        if (result.length > 32) {
            throw new Error('invalid length for ' + name);
        }
        return result;
    }
    const meta = transaction.customData;
    const fields = [
        formatNumber(transaction.nonce || 0, 'nonce'),
        formatNumber(transaction.gasPrice || 0, 'gasPrice'),
        formatNumber(transaction.gasLimit || 0, 'gasLimit'),
        transaction.to != null ? ethers_1.utils.getAddress(transaction.to) : '0x',
        formatNumber(transaction.value || 0, 'value'),
        transaction.data || '0x'
    ];
    if (signature) {
        const sig = ethers_1.utils.splitSignature(signature);
        fields.push(formatNumber(sig.recoveryParam, 'recoveryParam'));
        fields.push(ethers_1.utils.stripZeros(sig.r));
        fields.push(ethers_1.utils.stripZeros(sig.s));
    }
    else {
        fields.push(formatNumber(transaction.chainId, 'chainId'));
        fields.push('0x00');
        fields.push('0x00');
    }
    fields.push(formatNumber(transaction.chainId, 'chainId'));
    // Add meta
    fields.push(meta.feeToken || '0x');
    fields.push(meta.withdrawToken || '0x');
    fields.push(formatNumber(meta.ergsPerStorage || 0, 'ergsPerStorage'));
    fields.push(formatNumber(meta.ergsPerPubdata || 0, 'ergsPerPubdata'));
    fields.push(((_a = meta.factoryDeps) !== null && _a !== void 0 ? _a : []).map((dep) => ethers_1.utils.hexlify(dep)));
    return ethers_1.utils.hexConcat(['0x70', ethers_1.utils.RLP.encode(fields)]);
}
exports.serialize = serialize;
function parseTransaction(payload) {
    function handleAddress(value) {
        if (value === '0x') {
            return null;
        }
        return ethers_1.utils.getAddress(value);
    }
    function handleNumber(value) {
        if (value === '0x') {
            return ethers_1.BigNumber.from(0);
        }
        return ethers_1.BigNumber.from(value);
    }
    const bytes = ethers_1.utils.arrayify(payload);
    if (bytes[0] != 0x70) {
        return ethers_1.utils.parseTransaction(bytes);
    }
    const raw = ethers_1.utils.RLP.decode(bytes.slice(1));
    const transaction = {
        type: 0x70,
        nonce: handleNumber(raw[0]).toNumber(),
        gasPrice: handleNumber(raw[1]),
        gasLimit: handleNumber(raw[2]),
        to: handleAddress(raw[3]),
        value: handleNumber(raw[4]),
        data: raw[5],
        chainId: handleNumber(raw[9]),
        customData: {
            feeToken: handleAddress(raw[10]),
            withdrawToken: handleAddress(raw[11]),
            ergsPerStorage: handleNumber(raw[12]),
            ergsPerPubdata: handleNumber(raw[13]),
            factoryDeps: raw[14]
        }
    };
    const signature = {
        v: handleNumber(raw[6]).toNumber(),
        r: raw[7],
        s: raw[8]
    };
    if (ethers_1.utils.hexlify(signature.r) == '0x00' || ethers_1.utils.hexlify(signature.s) == '0x00') {
        return transaction;
    }
    transaction.hash = ethers_1.utils.keccak256(payload);
    if (signature.v !== 0 && signature.v !== 1) {
        throw new Error('Failed to parse signature');
    }
    const digest = signer_1.EIP712Signer.getSignedDigest(transaction);
    transaction.from = ethers_1.utils.recoverAddress(digest, {
        r: ethers_1.utils.hexZeroPad(signature.r, 32),
        s: ethers_1.utils.hexZeroPad(signature.s, 32),
        recoveryParam: signature.v
    });
    return transaction;
}
exports.parseTransaction = parseTransaction;
function getL2HashFromPriorityOpId(id) {
    id = ethers_1.BigNumber.from(id);
    const hexString = ethers_1.utils.hexZeroPad(id.toHexString(), exports.PRIORITY_OP_ID_BYTES);
    return ethers_1.ethers.utils.keccak256(hexString);
}
exports.getL2HashFromPriorityOpId = getL2HashFromPriorityOpId;
function getL2HashFromPriorityOp(txReceipt, zkSyncAddress) {
    let priorityOpId = null;
    for (const log of txReceipt.logs) {
        if (log.address.toLowerCase() != zkSyncAddress.toLowerCase()) {
            continue;
        }
        try {
            const priorityQueueLog = exports.ZKSYNC_MAIN_ABI.parseLog(log);
            if (priorityQueueLog && priorityQueueLog.args.serialId != null) {
                priorityOpId = priorityQueueLog.args.serialId;
            }
        }
        catch { }
    }
    if (!priorityOpId) {
        throw new Error('Failed to parse tx logs');
    }
    return getL2HashFromPriorityOpId(priorityOpId);
}
exports.getL2HashFromPriorityOp = getL2HashFromPriorityOp;
// The method with similar functionality is already available in ethers.js,
// the only difference is that we provide additional `try { } catch { }`
// for error-resilience.
//
// It will also pave the road for allowing future EIP-1271 signature verification, by
// letting our SDK have functionality to verify signatures.
function isECDSASignatureCorrect(address, msgHash, signature) {
    try {
        return address == ethers_1.ethers.utils.recoverAddress(msgHash, signature);
    }
    catch {
        // In case ECDSA signature verification has thrown an error,
        // we simply consider the signature as incorrect.
        return false;
    }
}
// Returns `true` or `false` depending on whether or not the account abstraction's
// signature is correct. Note, that while currently it does not do any `async` actions.
// in the future it will. That's why the `Promise<boolean>` is returned.
async function isMessageSignatureCorrect(address, message, signature) {
    const msgHash = ethers_1.ethers.utils.hashMessage(message);
    return isECDSASignatureCorrect(address, msgHash, signature);
}
exports.isMessageSignatureCorrect = isMessageSignatureCorrect;
// Returns `true` or `false` depending on whether or not the account abstraction's
// EIP712 signature is correct. Note, that while currently it does not do any `async` actions.
// in the future it will. That's why the `Promise<boolean>` is returned.
async function isTypedDataSignatureCorrect(address, domain, types, value, signature) {
    const msgHash = ethers_1.ethers.utils._TypedDataEncoder.hash(domain, types, value);
    return isECDSASignatureCorrect(address, msgHash, signature);
}
exports.isTypedDataSignatureCorrect = isTypedDataSignatureCorrect;
// Throws error if transaction is not a withdrawal and contains non-zero value.
function checkNonZeroValue(transaction) {
    var _a;
    const isWithdraw = transaction.customData != null &&
        transaction.customData.withdrawToken != null &&
        transaction.customData.withdrawToken != ethers_1.ethers.constants.AddressZero;
    if (!isWithdraw && !ethers_1.BigNumber.from((_a = transaction.value) !== null && _a !== void 0 ? _a : 0).isZero()) {
        throw new Error('Non-zero value is not supported for transactions');
    }
}
exports.checkNonZeroValue = checkNonZeroValue;
