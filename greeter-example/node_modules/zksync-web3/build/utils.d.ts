import { utils, ethers, BigNumberish } from 'ethers';
import { SignatureLike } from '@ethersproject/bytes';
import { Address, PriorityQueueType, PriorityOpTree, TransactionRequest } from './types';
import { TypedDataDomain, TypedDataField } from '@ethersproject/abstract-signer';
export declare const ETH_ADDRESS = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE";
export declare const ZKSYNC_MAIN_ABI: utils.Interface;
export declare const IERC20: utils.Interface;
export declare const PRIORITY_OP_ID_BYTES = 8;
export declare const RECOMMENDED_GAS_LIMIT: {
    ETH_DEPOSIT: number;
    ERC20_DEPOSIT: any;
    ERC20_DEFAULT_DEPOSIT: number;
    WITHDRAW: number;
    EXECUTE: number;
    DEPLOY_CONTRACT: number;
    ADD_TOKEN: number;
    TRANSFER: number;
    ERC20_APPROVE: number;
};
export declare function isETH(token: Address): boolean;
export declare function sleep(millis: number): Promise<unknown>;
export declare function layer1TxDefaults(): {
    queueType: PriorityQueueType;
    opTree: PriorityOpTree;
};
export declare function checkBaseCost(baseCost: ethers.BigNumber, value: ethers.BigNumberish | Promise<ethers.BigNumberish>): Promise<void>;
export declare function serialize(transaction: ethers.providers.TransactionRequest, signature?: SignatureLike): string;
export declare function parseTransaction(payload: ethers.BytesLike): ethers.Transaction;
export declare function getL2HashFromPriorityOpId(id: BigNumberish): string;
export declare function getL2HashFromPriorityOp(txReceipt: ethers.providers.TransactionReceipt, zkSyncAddress: Address): string;
export declare function isMessageSignatureCorrect(address: string, message: ethers.Bytes | string, signature: SignatureLike): Promise<boolean>;
export declare function isTypedDataSignatureCorrect(address: string, domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>, signature: SignatureLike): Promise<boolean>;
export declare function checkNonZeroValue(transaction: TransactionRequest): void;
